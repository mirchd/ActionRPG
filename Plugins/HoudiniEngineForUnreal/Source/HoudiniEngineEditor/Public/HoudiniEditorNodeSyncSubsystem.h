// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "HoudiniApi.h"
#include "HoudiniEngine.h"
#include "HoudiniEngineEditorPrivatePCH.h"
#include "HoudiniInput.h"
#include "HoudiniNodeSyncComponent.h"

#include "CoreMinimal.h"
#include "EditorSubsystem.h"
#include "Toolkits/AssetEditorModeUILayer.h"

#include "HoudiniEditorNodeSyncSubsystem.generated.h"

class USkeletalMesh;


USTRUCT()
struct HOUDINIENGINEEDITOR_API FHoudiniNodeSyncOptions
{
	GENERATED_BODY()

public:

	UPROPERTY()
	FString FetchNodePath = "/obj/...";

	UPROPERTY()
	FString SendNodePath = "/obj/UnrealContent";

	UPROPERTY()
	FString UnrealAssetName = "";

	UPROPERTY()
	FString UnrealAssetFolder = "/Game/NodeSync";

	UPROPERTY()
	bool bUseOutputNodes = true;

	UPROPERTY()
	bool bFetchToWorld = false;

	UPROPERTY()
	FString UnrealActorName = "";

	UPROPERTY()
	FString UnrealActorFolder = "/Houdini/NodeSync";

	UPROPERTY()
	bool bReplaceExisting = false;

	UPROPERTY()
	bool bOverwriteSkeleton = false;

	UPROPERTY()
	FString SkeletonAssetPath = "";	

	UPROPERTY()
	bool bAutoBake = false;

	UPROPERTY()
	bool bSyncWorldInput = false;

	// Generation properties for the Static Meshes generated by this Houdini Asset
	UPROPERTY(Category = "HoudiniMeshGeneration", EditAnywhere, meta = (DisplayPriority = 1)/*, meta = (ShowOnlyInnerProperties)*/)
	FHoudiniStaticMeshGenerationProperties StaticMeshGenerationProperties;

	// Build Settings to be used when generating the Static Meshes for this Houdini Asset
	UPROPERTY(Category = "HoudiniMeshGeneration", EditAnywhere, meta = (DisplayPriority = 2))
	FMeshBuildSettings StaticMeshBuildSettings;

	// Returns the number of node paths in FetchNodePath - they're separated by ";"
	int32 
	GetNumberOfFetchNodePaths()
	{
		// Parse the fetch node path into a string array
		TArray<FString> FetchNodePathsArray;
		FetchNodePath.ParseIntoArray(FetchNodePathsArray, TEXT(";"), true);
		return FetchNodePathsArray.Num();
	};

	FString
	GetFetchNodePathAt(int32 PathIdx = 0)
	{
		// Parse the fetch node path into a string array
		TArray<FString> FetchNodePathsArray;
		FetchNodePath.ParseIntoArray(FetchNodePathsArray, TEXT(";"), true);

		if (!FetchNodePathsArray.IsValidIndex(PathIdx))
			return FString();
		else
			return FetchNodePathsArray[PathIdx];
	};

	FString
	GetFetchNodeNameAt(int32 PathIdx = 0)
	{
		FString NodePathAt = GetFetchNodePathAt(PathIdx);
		
		FString NodeNameAt = FString();
		int32 FoundPos = -1;
		if (NodePathAt.FindLastChar(TEXT('/'), FoundPos))
		{
			NodeNameAt = NodePathAt.RightChop(FoundPos + 1);
		}

		return NodeNameAt;
	};

	FString 
	GetUnrealAssetName(int32 PathIdx = 0)
	{
		if (!UnrealAssetName.IsEmpty())
			return UnrealAssetName;

		FString NodeName = GetFetchNodeNameAt(PathIdx);
		if (!NodeName.IsEmpty())
			return NodeName;

		// If we don't have a valid name/path - return a default one
		return TEXT("NodeSyncAsset");
	};

	FString 
	GetUnrealActorLabel(int32 PathIdx = 0)
	{
		FString NodeName = GetFetchNodeNameAt(PathIdx);
		if (!NodeName.IsEmpty())
			return NodeName;

		// If we don't have a valid name/path - return a default one
		return TEXT("HoudiniNodeSyncActor");
	};
};



UCLASS()
class HOUDINIENGINEEDITOR_API UHoudiniEditorNodeSyncSubsystem : public UAssetEditorUISubsystem
{
	GENERATED_BODY()

public:

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	
	// Register layout for tab placement
	virtual void RegisterLayoutExtensions(FLayoutExtender& Extender) override;

public:

	UFUNCTION(BlueprintCallable, Category = "Houdini")
	void SendToHoudini(const TArray<UObject*>& SelectedAssets, int32 ObjectIndex, const bool& bSendWorld);

	UFUNCTION(BlueprintCallable, Category = "Houdini")
	void FetchFromHoudini();
	
	UFUNCTION(BlueprintCallable, Category = "Houdini")
	void SendWorldSelection();

	UFUNCTION(BlueprintCallable, Category = "Houdini")
	void SendContentBrowserSelection(const TArray<UObject*>& SelectedAssets);

	bool CreateSessionIfNeeded();

	// Returns the color corresponding to a given node sync status
	static FLinearColor GetStatusColor(const EHoudiniNodeSyncStatus& Status);

	bool GetNodeSyncWorldInput(UHoudiniInput*& OutInput);

	bool GetNodeSyncCBInput(UHoudiniInput*& OutInput);

	bool GatherAllFetchedNodeIds(
		HAPI_NodeId UnrealFetchNodeId,
		const bool bUseOutputNodes,
		TArray<HAPI_NodeId>& OutOutputNodes);

	bool ValidateFetchedNodePath(
		const FString& InFetchedNodePath,
		HAPI_NodeId& OutFetchedNodeId);

	// Node Sync ticks
	void StartTicking();
	void StopTicking();
	bool IsTicking() const;
	bool Tick(float DeltaTime);

	bool CheckNodeSyncInputNodesValid();

	bool UpdateNodeSyncInputs();

	void UpdateAllSelection();

	void DeleteAllSelection();

	//
	// Public Members
	//
	
	// Node sync options
	FHoudiniNodeSyncOptions NodeSyncOptions;

	// SEND status
	EHoudiniNodeSyncStatus LastSendStatus = EHoudiniNodeSyncStatus::None;
	FString SendStatusMessage;
	FString SendStatusDetails;

	// FETCH status
	EHoudiniNodeSyncStatus LastFetchStatus = EHoudiniNodeSyncStatus::None;
	FString FetchStatusMessage;
	FString FetchStatusDetails;

private:

	bool InitNodeSyncInputsIfNeeded();

	UPROPERTY()
	TObjectPtr<UHoudiniInput> NodeSyncWorldInput;

	UPROPERTY()
	TObjectPtr<UHoudiniInput> NodeSyncCBInput;

	// Ticker handle, used for processing HAC.
	FTSTicker::FDelegateHandle TickerHandle;

	// Stopping flag. 
	// Indicates that we should stop ticking asap
	bool bMustStopTicking;

	// Last time we ticked NodeSync
	double dLastTick;
};
